// Code generated by gowrap. DO NOT EDIT.
// template: ../../../templates/circuitbreaker
// gowrap: http://github.com/hexdigest/gowrap

package generated

import (
	"context"
	"errors"
	_sourceExternal "goWrapExample/internal/external"
	"sync"
	"time"
)

// TodoListWithCircuitBreaker implements _sourceExternal.TodoList instrumented with circuit breaker
type TodoListWithCircuitBreaker struct {
	_sourceExternal.TodoList

	_lock                 sync.RWMutex
	_maxConsecutiveErrors int
	_consecutiveErrors    int
	_openInterval         time.Duration
	_closesAt             *time.Time
	_ignoreErrors         []error
}

// NewTodoListWithCircuitBreaker breakes a circuit after consecutiveErrors of errors and closes the circuit again after openInterval of time.
// If, after openInterval, the first method call results in error we open and close again.
func NewTodoListWithCircuitBreaker(base _sourceExternal.TodoList, consecutiveErrors int, openInterval time.Duration, ignoreErrors ...error) *TodoListWithCircuitBreaker {
	return &TodoListWithCircuitBreaker{
		TodoList:              base,
		_maxConsecutiveErrors: consecutiveErrors,
		_openInterval:         openInterval,
		_ignoreErrors:         ignoreErrors,
	}
}

// Add implements _sourceExternal.TodoList
func (_d *TodoListWithCircuitBreaker) Add(ctx context.Context, text string) (s1 string, err error) {
	_d._lock.RLock()

	if _d._closesAt != nil && _d._closesAt.After(time.Now()) {
		_d._lock.RUnlock()
		err = errors.New("TodoListWithCircuitBreaker: circuit is open")
		return
	}
	_d._lock.RUnlock()

	s1, err = _d.TodoList.Add(ctx, text)
	_d._lock.Lock()
	defer _d._lock.Unlock()

	if err == nil {
		_d._consecutiveErrors = 0
		_d._closesAt = nil
		return
	}

	for _, _e := range _d._ignoreErrors {
		if errors.Is(err, _e) {
			_d._consecutiveErrors = 0
			_d._closesAt = nil
			return
		}
	}

	_d._consecutiveErrors++

	if _d._consecutiveErrors >= _d._maxConsecutiveErrors {
		closesAt := time.Now().Add(_d._openInterval)
		_d._closesAt = &closesAt
	}

	return
}

// List implements _sourceExternal.TodoList
func (_d *TodoListWithCircuitBreaker) List(ctx context.Context) (sa1 []string, err error) {
	_d._lock.RLock()

	if _d._closesAt != nil && _d._closesAt.After(time.Now()) {
		_d._lock.RUnlock()
		err = errors.New("TodoListWithCircuitBreaker: circuit is open")
		return
	}
	_d._lock.RUnlock()

	sa1, err = _d.TodoList.List(ctx)
	_d._lock.Lock()
	defer _d._lock.Unlock()

	if err == nil {
		_d._consecutiveErrors = 0
		_d._closesAt = nil
		return
	}

	for _, _e := range _d._ignoreErrors {
		if errors.Is(err, _e) {
			_d._consecutiveErrors = 0
			_d._closesAt = nil
			return
		}
	}

	_d._consecutiveErrors++

	if _d._consecutiveErrors >= _d._maxConsecutiveErrors {
		closesAt := time.Now().Add(_d._openInterval)
		_d._closesAt = &closesAt
	}

	return
}

// Remove implements _sourceExternal.TodoList
func (_d *TodoListWithCircuitBreaker) Remove(ctx context.Context, id string) (s1 string, err error) {
	_d._lock.RLock()

	if _d._closesAt != nil && _d._closesAt.After(time.Now()) {
		_d._lock.RUnlock()
		err = errors.New("TodoListWithCircuitBreaker: circuit is open")
		return
	}
	_d._lock.RUnlock()

	s1, err = _d.TodoList.Remove(ctx, id)
	_d._lock.Lock()
	defer _d._lock.Unlock()

	if err == nil {
		_d._consecutiveErrors = 0
		_d._closesAt = nil
		return
	}

	for _, _e := range _d._ignoreErrors {
		if errors.Is(err, _e) {
			_d._consecutiveErrors = 0
			_d._closesAt = nil
			return
		}
	}

	_d._consecutiveErrors++

	if _d._consecutiveErrors >= _d._maxConsecutiveErrors {
		closesAt := time.Now().Add(_d._openInterval)
		_d._closesAt = &closesAt
	}

	return
}
