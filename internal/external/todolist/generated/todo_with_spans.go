// Code generated by gowrap. DO NOT EDIT.
// template: ../../../templates/opentracing
// gowrap: http://github.com/hexdigest/gowrap

package generated

import (
	"context"
	_sourceExternal "goWrapExample/internal/external"

	opentracing "github.com/opentracing/opentracing-go"

	_ext "github.com/opentracing/opentracing-go/ext"

	_log "github.com/opentracing/opentracing-go/log"
)

// TodoListWithTracing implements _sourceExternal.TodoList interface instrumented with opentracing spans
type TodoListWithTracing struct {
	_sourceExternal.TodoList
	_instance      string
	_spanDecorator func(span opentracing.Span, params, results map[string]interface{})
}

// NewTodoListWithTracing returns TodoListWithTracing
func NewTodoListWithTracing(base _sourceExternal.TodoList, instance string, spanDecorator ...func(span opentracing.Span, params, results map[string]interface{})) TodoListWithTracing {
	d := TodoListWithTracing{
		TodoList:  base,
		_instance: instance,
	}

	if len(spanDecorator) > 0 && spanDecorator[0] != nil {
		d._spanDecorator = spanDecorator[0]
	}

	return d
}

// Add implements _sourceExternal.TodoList
func (_d TodoListWithTracing) Add(ctx context.Context, text string) (s1 string, err error) {
	_span, ctx := opentracing.StartSpanFromContext(ctx, _d._instance+"._sourceExternal.TodoList.Add")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx":  ctx,
				"text": text}, map[string]interface{}{
				"s1":  s1,
				"err": err})
		} else if err != nil {
			_ext.Error.Set(_span, true)
			_span.LogFields(
				_log.String("event", "error"),
				_log.String("message", err.Error()),
			)
		}

		_span.Finish()
	}()
	return _d.TodoList.Add(ctx, text)
}

// List implements _sourceExternal.TodoList
func (_d TodoListWithTracing) List(ctx context.Context) (sa1 []string, err error) {
	_span, ctx := opentracing.StartSpanFromContext(ctx, _d._instance+"._sourceExternal.TodoList.List")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx}, map[string]interface{}{
				"sa1": sa1,
				"err": err})
		} else if err != nil {
			_ext.Error.Set(_span, true)
			_span.LogFields(
				_log.String("event", "error"),
				_log.String("message", err.Error()),
			)
		}

		_span.Finish()
	}()
	return _d.TodoList.List(ctx)
}

// Remove implements _sourceExternal.TodoList
func (_d TodoListWithTracing) Remove(ctx context.Context, id string) (s1 string, err error) {
	_span, ctx := opentracing.StartSpanFromContext(ctx, _d._instance+"._sourceExternal.TodoList.Remove")
	defer func() {
		if _d._spanDecorator != nil {
			_d._spanDecorator(_span, map[string]interface{}{
				"ctx": ctx,
				"id":  id}, map[string]interface{}{
				"s1":  s1,
				"err": err})
		} else if err != nil {
			_ext.Error.Set(_span, true)
			_span.LogFields(
				_log.String("event", "error"),
				_log.String("message", err.Error()),
			)
		}

		_span.Finish()
	}()
	return _d.TodoList.Remove(ctx, id)
}
